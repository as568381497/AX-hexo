<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>iOS之组件化 | AXIHOME</title>



    <link rel="icon" href="/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    


<meta name="generator" content="Hexo 6.0.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">阿西&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">阿西&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div id="post-toc" class="post-toc">
            <span class="post-toc-title">catalogue</span>
            <div class="post-toc-content">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%8E%E4%B9%88%E6%8B%86%E5%88%86%E7%BB%84%E4%BB%B6"><span class="toc-text">1.怎么拆分组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86%E5%90%8E%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-text">2.组件拆分后的存放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">3.组件间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%88EventBus%EF%BC%89"><span class="toc-text">1.事件总线（EventBus）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-text">2.全局数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="toc-text">3.基于URL Scheme的路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8ERuntime%E7%9A%84target-action"><span class="toc-text">4.基于Runtime的target-action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%EF%BC%88%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-text">5.接口服务（面向接口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%90%84%E8%87%AA%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9"><span class="toc-text">4.各自适用的场景选择</span></a></li></ol>
            </div>
        </div>
    
    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">iOS之组件化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chen Xin</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 5, 2024&nbsp;&nbsp;18:23:26</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/iOS/">iOS</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <section class="post-content">
            <p>组件化的意思很简单，就是将我们开发中用到的东西，拆分成一个个的组件。</p>
<p>这句话很简单，其中有两个意思，一个是，怎么拆分，另外一个是拆分后怎么放的问题</p>
<h2 id="1-怎么拆分组件"><a href="#1-怎么拆分组件" class="headerlink" title="1.怎么拆分组件"></a>1.怎么拆分组件</h2><p>组件拆分，其实是一个很复杂的问题，并不是所有的项目按照固定的某些东西拆分，而是按照项目需不需要来拆分，简单的项目，都不用这些东西，当项目需要的时候，才会涉及到组件化的问题，拆分的化，就是根据项目，根据自己的经验，拆分成一定颗粒度合适的组件，但是，大概的话，可以根据一下几层来拆分，比如：</p>
<ol>
<li>基础组件： 这类组件通常包括一些工具性质的基础类，如网络请求、数据库操作、图片加载等，可以被所有其他组件所复用。这些组件一般不存在相互依赖关系。 </li>
<li>业务组件： 这类组件更多的是封装具体的业务逻辑，比如 “用户模块”, “订单模块”, “支付模块” 等。在这一层级的组件设计上，我们通常会有一些抽象的设计上的引导，比如采用 MVP, MVVM 等设计模式。 </li>
<li>应用组件： 应用组件，也被称为壳工程，在组件化架构中，主要负责协调组装各个业务组件，形成可以独立运行的完整APP。它并不包含具体的业务逻辑，它的作用主要是启动和初始化各个业务模块，同时将这些模块有机地组合在一起。其他业务组件将以此应用组件为载体，被整合进一个完整的应用之中。 </li>
<li>服务组件： 服务组件在组件化架构中起到非常重要的作用，由于业务组件之间不能直接进行通信，因此，需要服务组件来进行跨组件的通信。服务组件的主要职责是管理和协调各个业务组件的通信。 服务组件提供了一种解决业务间依赖、耦合问题的手段。它能够降低各个组件之间的依赖，提高组件的复用性。例如，”用户服务”可以封装整个用户系统的功能，如登录、注册、用户信息查询等，其他如订单、社区等模块如需要使用用户服务，只需引用”用户服务”即可，而不需要对接具体的用户模块。 服务组件还可以帮助处理一些全局的事件，例如播放音乐、网络监听、权限请求等。</li>
</ol>
<p>以上就是在原有架构基础上增加组件化的设计思想的大致方案，具体实现还需要根据实际业务逻辑进行分析和设计。</p>
<p>基础组件和业务组件好理解，应用组件和服务组件就比较麻烦一点，但是也是最重要两部分。</p>
<h2 id="2-组件拆分后的存放"><a href="#2-组件拆分后的存放" class="headerlink" title="2.组件拆分后的存放"></a>2.组件拆分后的存放</h2><p>在我们项目中，一般情况下，项目没那么复杂，大的情况下，就是可以直接以类别的方式，以文件的形式存放在项目里面统一管理，这是第一种。</p>
<p>但是在公司主要项目的情况下，项目的复杂度都比较庞大，所以这个时候就要用一些工具来管理组件了，比如iOS中，我们一想到这个，第一选择肯定是cocopod，也就是将我们的组件做成静态库，以给到其他人那边使用，这也是一种方式，而且基于pod，也很好管理和使用。</p>
<h2 id="3-组件间通信"><a href="#3-组件间通信" class="headerlink" title="3.组件间通信"></a>3.组件间通信</h2><p>在这里面，还有一个很中重要的问题，那就是组件之间的通信问题，也就是服务组件需要解决的问题，那么，怎么来解决这个问题呢，一般我们有五种方式，三种主流打的，两种简单的。</p>
<p>简单的：</p>
<ol>
<li>事件总线（EventBus）：事件总线是观察者模式的一种实现，通过发布/订阅的方式进行组件间的通信。业务组件可以通过事件总线发布事件，其他感兴趣的业务组件可以接收到这个事件进行相应的处理。在 iOS 中并不常见，iOS 开发者通常会倾向于使用 Delegate 或者 Notification Center 来进行跨组件通信。</li>
<li>全局数据共享：这种方式主要是通过共享内存、单例等方式来实现数据的共享。例如，我们可以创建全局的用户信息类，所有的业务组件都可以通过这个类来获取用户信息。</li>
</ol>
<p>主流的：</p>
<ol>
<li>基于URL Scheme的路由： URL Scheme是一种通过预定义的URL来进行页面跳转和数据传递的一种机制。其基本想法是将APP中的每个页面看成是一个网站，通过定义好的URL来定位这个页面，并根据URL中的参数来传递数据。这种方式的优点是简单易懂，可以灵活的进行页面跳转和数据传递。这种设计思路可以在一定程度上解耦各个模块间的直接依赖，同样有利于各个模块的独立开发和调试。</li>
<li>基于Runtime的target-action： 这种方式利用的是Objective-C的Runtime特性，允许我们在运行时动态地创建类、方法等。target-action方式就是通过动态处理对象之间的通信，比如iOS中常见的UIButton的点击事件处理就是这种方式。这种方式能有效地减小组件之间的耦合，有利于代码的复用和扩展。</li>
<li>面向接口编程： 面向接口编程是一种编程方式，其主要思想是把接口和实现分离，使得每个模块对外只暴露接口，而具体的实现则隐藏起来。这种设计方式能有效地降低模块间的耦合，提高代码的复用性，可读性以及可维护性。 </li>
</ol>
<h3 id="1-事件总线（EventBus）"><a href="#1-事件总线（EventBus）" class="headerlink" title="1.事件总线（EventBus）"></a>1.事件总线（EventBus）</h3><p>其实这个就是我们常说的的通知（NotificationCenter），包括两步，注册通知和发布通知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        // 注册监听的事件</span><br><span class="line">        NotificationCenter.default.addObserver(self, selector: #selector(handleEvent(notification:)), name: NSNotification.Name(rawValue: &quot;MyEvent&quot;), object: nil)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理事件</span><br><span class="line">    @objc private func handleEvent(notification: NSNotification) &#123;</span><br><span class="line">        // 这里是当事件发生时，我们要执行的代码</span><br><span class="line">        ...</span><br><span class="line">    &#125;&#125;</span><br><span class="line">接着，在需要发布这个事件的地方，我们就可以这样操作：</span><br><span class="line">class AnotherClass: NSObject &#123;</span><br><span class="line">    func triggerEvent() &#123;</span><br><span class="line">        // 发布事件</span><br><span class="line">        NotificationCenter.default.post(name: NSNotification.Name(rawValue: &quot;MyEvent&quot;), object: nil)</span><br><span class="line">    &#125;&#125; </span><br></pre></td></tr></table></figure>
<p>在上面的代码中，“MyEvent”就像是我们在事件总线中的一个频道，任何对这个事件感兴趣的类都可以通过注册监听这个事件的方式，来接收对应的通知。需要注意的是注册了事件监听后，一定要在适当的时机移除监听，如在deinit方法中，防止不必要的内存泄露。</p>
<h3 id="2-全局数据共享"><a href="#2-全局数据共享" class="headerlink" title="2.全局数据共享"></a>2.全局数据共享</h3><p>这个很好说明，像我们日常用的单例，本地的文件缓存，都算是全局的数据共享，当然，最重要的是单例，还有静态的全局数据。</p>
<h3 id="3-基于URL-Scheme的路由"><a href="#3-基于URL-Scheme的路由" class="headerlink" title="3.基于URL Scheme的路由"></a>3.基于URL Scheme的路由</h3><p>在iOS的组件化开发中，基于URL Scheme的路由方法也经常被使用来实现组件间的通信和解耦,我们可以通过一个Router类来注册并管理URL与处理方法的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Router &#123; </span><br><span class="line">static let shared = Router() private var routes = [String: (([String: Any]) -&gt; Void)]() </span><br><span class="line">    func register(_ url: String, handler: @escaping ([String: Any]) -&gt; Void) &#123;</span><br><span class="line">        routes[url] = handler &#125; func open(_ url: String) &#123; if let handler = routes[url] &#123; handler([:]) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>然后，我们可以在不同的组件中注册相应的URL和处理方法。比如在用户信息组件中，我们可以注册URL <code>myapp://user</code>，以表示用户信息页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router.shared.register(&quot;myapp://user&quot;) &#123; parameters in // 处理用户信息页面的展示 &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，其他组件或者其他地方可以通过Router打开注册的URL，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router.shared.open(&quot;myapp://user&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，组件之间就可以通过URL来进行通信了。这种方式的优点是，组件之间没有任何硬依赖，只需要知道相应的URL即可，增强了组件间的解耦。同时，由于所有的URL都集中管理在Router中，也方便我们进行管理和维护。</p>
<h3 id="4-基于Runtime的target-action"><a href="#4-基于Runtime的target-action" class="headerlink" title="4.基于Runtime的target-action"></a>4.基于Runtime的target-action</h3><p>在iOS的组件化开发中，基于Runtime的target-action方法也经常被用于实现组件间的通信和解耦。<br>下面就给你举个简单的例子说明:<br>假设我们有一个UserModule模块，处理和用户相关的业务逻辑，它里面有一个<code>UserProfileViewController</code>，其他模块如果想要获取<code>UserProfileViewController</code>并展示用户的个人信息，就需要引入UserModule模块，造成了耦合。<br>为了解耦，我们可以创建一个单独的<code>Mediator</code>类，使用Runtime的特性进行模块间的通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 这里应该是待展示的用户名 </span><br><span class="line">let userName: String? </span><br><span class="line"></span><br><span class="line">let userProfileVCClass = NSClassFromString(&quot;UserModule.UserProfileViewController&quot;) as? UIViewController.Type </span><br><span class="line"></span><br><span class="line">if let Type = userProfileVCClass &#123; </span><br><span class="line"></span><br><span class="line">   // 这里的setUserName:方法应当在UserProfileViewController中声明和实现，用于设置用户名并刷新UI </span><br><span class="line">   let vc = Type.init() vc.perform(Selector((&quot;setUserName:&quot;)), with: userName) </span><br><span class="line"></span><br><span class="line">   navigationController.pushViewController(vc, animated: true) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先通过<code>NSClassFromString</code>函数获得了<code>UserProfileViewController</code>这个类，然后创建了它的实例，并通过<code>perform</code>函数调用了它的<code>setUserName:</code>方法来设置用户名。<br>最后，我们将得到的<code>UserProfileViewController</code>的实例push到导航控制器中，从而展示用户个人信息。 </p>
<p>这种方式的好处是，我们并不需要引入UserModule模块，只需要知道UserProfileViewController的类名和方法名就可以了。并且，由于我们是通过字符串来指定类名和方法名，因此这个代码可以放在任何地方，模块之间可以完全解耦，提高了模块的复用性和可维护性。</p>
<h3 id="5-接口服务（面向接口）"><a href="#5-接口服务（面向接口）" class="headerlink" title="5.接口服务（面向接口）"></a>5.接口服务（面向接口）</h3><p>在iOS中，定义接口服务就是定义协议：</p>
<p>首先，我们定义一个服务接口，这里我们以音乐播放为例，定义一个 MusicService 接口（在 Swift 中，接口被称为 protocol）。MusicService 提供 play 和 pause 两个服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol MusicService &#123;</span><br><span class="line">    func play(song: String)</span><br><span class="line">    func pause()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以创建一个 MusicManager 类来实现这个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MusicManager: MusicService &#123;</span><br><span class="line">    func play(song: String) &#123;</span><br><span class="line">        print(&quot;\(song) is now playing.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func pause() &#123;</span><br><span class="line">        print(&quot;Music paused.&quot;)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在需要使用音乐服务的类中，我们可以通过接口（协议）来调用音乐服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MusicViewController: UIViewController &#123;</span><br><span class="line">    private let musicService: MusicService</span><br><span class="line"></span><br><span class="line">    init(musicService: MusicService) &#123;</span><br><span class="line">        self.musicService = musicService</span><br><span class="line">        super.init(nibName: nil, bundle: nil)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func userDidPressPlayButton() &#123;</span><br><span class="line">        musicService.play(song: &quot;My Favorite Song&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func userDidPressPauseButton() &#123;</span><br><span class="line">        musicService.pause()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际应用中，我们通常会在外部（例如在 App 的初始化过程中，或者通过依赖注入的方式）将实现了 MusicService 接口的对象传入 MusicViewController。</p>
<p>通过这种方式，MusicViewController 不直接依赖 MusicManager，而是依赖 MusicService 接口。</p>
<p>MusicManager 是实现了 MusicService 协议，因而它也就提供了 play 和 pause 两种方法。具体调用这两种方法的实例是在 MusicViewController 中：</p>
<p>1.应用开始运行的时候，比如在 AppDelegate 中，我们会实例化 MusicManager 和 MusicViewController。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line">    var window: UIWindow?</span><br><span class="line"></span><br><span class="line">    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;</span><br><span class="line">        </span><br><span class="line">        let musicManager: MusicService = MusicManager()</span><br><span class="line">        let musicViewController = MusicViewController(musicService: musicManager)</span><br><span class="line"></span><br><span class="line">        // 将musicViewController设置为rootViewController,这通常会在一个navigation controller或者a tabBar controller中进行</span><br><span class="line">        window = UIWindow(frame: UIScreen.main.bounds)</span><br><span class="line">        window?.rootViewController = musicViewController</span><br><span class="line">        window?.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.当 MusicViewController 中的用户点击播放或暂停按钮时，如果你在按钮的点击事件中调用了 userDidPressPlayButton 或 userDidPressPauseButton，那么就会触发 MusicManager 中的 play 或 pause 方法。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc func playButtonDidTap() &#123;</span><br><span class="line">userDidPressPlayButton()&#125;</span><br><span class="line">@objc func pauseButtonDidTap() &#123;</span><br><span class="line">    userDidPressPauseButton()&#125;</span><br></pre></td></tr></table></figure>
<p>这样，用户的行为就能直接通过接口服务触发播放器的播放或暂停操作了。</p>
<h2 id="4-各自适用的场景选择"><a href="#4-各自适用的场景选择" class="headerlink" title="4.各自适用的场景选择"></a>4.各自适用的场景选择</h2><p>以上是五种组件通信方式在具体场景该怎么选择呢，可以一些参考：</p>
<ol>
<li>事件总线（EventBus）：适合在组件间有跨级别、异步通信需求的场景。例如，不相关的视图组件需要共享某个状态时，或者在大型应用中广播特定的事件信号。</li>
<li>全局数据共享：当多个组件需要实时共享某些状态或者数据时，全局数据共享是非常好的方式。例如，在多用戶实时协作编辑文档的场景中，全局数据共享可以实时同步展示所有用户的修改。</li>
<li>基于URL Scheme的路由：非常适合前端Web开发的场景，将每个页面当作一个独立的资源，通过URL来定位和传递参数，这样可以方便地组织和管理页面之间的关系，也便于添加新的页面和功能。 </li>
<li>基于Runtime的target-action：在iOS开发中尤其常见。因为Runtime的动态特性，使得这种方式能够在运行时动态处理对象之间的通信，动态创建类、方法等，可以更灵活地实现按钮点击、界面跳转等操作。</li>
<li>面向接口编程：当需要解耦组件之间的直接依赖关系时很有用，将一些公共的、多个组件都可能使用的功能抽象为接口服务，可以降低代码的重复性和耦合度，或者当你预计一个功能或模块将会有多个可能的实现方式或者变化时，面向接口编程是很好的选择。这能确保代码的扩展性和可维护性，让你可以在不改动原有接口的前提下添加新特性或进行重构。</li>
</ol>

        </section>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chen Xin</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://axibreaking.ml/2024/01/05/2024/iOS%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96/">http://axibreaking.ml/2024/01/05/2024/iOS%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/iOS/"># iOS</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2023/07/11/2023/iOS%E4%B9%8B%E9%9D%99%E6%80%81%E5%BA%93%E7%94%9F%E6%88%90/">iOS之静态库生成</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chen Xin | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Sirice19/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
    </div>
</body>
</html>